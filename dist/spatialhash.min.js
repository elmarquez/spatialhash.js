/* Copyright (c) 2016 Davis Marques <davis.marques@unimelb.edu.au> (http://www.davismarques.com). Compiled 2016-02-22 11:02:02 */

"use strict";function SpatialHash(config){config=config||{};var self=this;self.INDEXING_STRATEGY={BOUNDED:"getBoundedHashKey",UNBOUNDED:"getUnboundedHashKey"},self.cells={},self.cellSize=10,self.conversionFactor=-1,self.envelopes={},self.hashFn=null,self.indexingStrategy=self.INDEXING_STRATEGY.UNBOUNDED,self.max=1e3,self.min=0,self.objects={},Object.keys(config).forEach(function(key){self[key]=config[key]}),self.conversionFactor=1/self.cellSize,self.hashFn=self[self.indexingStrategy],self.width=(self.max-self.min)/self.cellSize}SpatialHash.prototype.clear=function(){this.cells={},this.objects={}},SpatialHash.prototype.getBoundedHashKey=function(pos){if(pos[0]<0||pos[1]<0||pos[2]<0)throw new Error("Negative position value is not allowed");if(pos[0]>this.max||pos[1]>this.max||pos[2]>this.max)throw new Error("Position is greater than MAX");if(pos[0]<this.min||pos[1]<this.min||pos[2]<this.min)throw new Error("Position is less than MIN");return Math.floor(pos[0]*this.conversionFactor)+":"+Math.floor(pos[1]*this.conversionFactor)+":"+Math.floor(pos[2]*this.conversionFactor)},SpatialHash.prototype.getCellsIntersectingAABB=function(aabb,size){var i,j,k,points=[],max={x:Math.ceil(aabb.max.x/size)*size,y:Math.ceil(aabb.max.y/size)*size,z:aabb.max.z?Math.ceil(aabb.max.z/size)*size:0},min={x:Math.floor(aabb.min.x/size)*size,y:Math.floor(aabb.min.y/size)*size,z:aabb.min.z?Math.floor(aabb.min.z/size)*size:0};for(i=min.x;i<max.x;i+=size)for(j=min.y;j<max.y;j+=size)for(k=min.z;k<max.z;k+=size)points.push([i,j,k]);return points},SpatialHash.prototype.getCellsIntersectingFrustum=function(frustum){var intersects=[],self=this;return Object.keys(self.envelopes).forEach(function(cell){frustum.intersectsBox(self.envelopes[cell])&&intersects.push(cell)}),intersects},SpatialHash.prototype.getDistance=function(p1,p2){return p1[2]=2===p1.length?0:p1[2],p2[2]=2===p2.length?0:p2[2],Math.sqrt(Math.pow(p2[2]-p1[2],2)+Math.pow(p2[1]-p1[1],2)+Math.pow(p2[0]-p1[0],2))},SpatialHash.prototype.getEntitiesIntersectingFrustum=function(frustum){var intersects=[],cells=this.getCellsIntersectingFrustum(frustum);return cells.forEach(function(cell){}),intersects},SpatialHash.prototype.getEntitiesIntersectingScreenRectangle=function(p1,p2){var intersects=[];return intersects},SpatialHash.prototype.getUnboundedHashKey=function(pos){return Math.floor(pos[0]*this.conversionFactor)+":"+Math.floor(pos[1]*this.conversionFactor)+":"+Math.floor(pos[2]*this.conversionFactor)},SpatialHash.prototype.insert=function(id,aabb){var key,self=this,cells=self.getCellsIntersectingAABB(aabb,this.cellSize).reduce(function(entries,p){return key=self.hashFn(p),entries[key]=new THREE.Box3(p[0],p[1],p[2]),entries},{});Object.keys(cells).forEach(function(cell){self.cells.hasOwnProperty(cell)||(self.cells[cell]=[]),self.cells[cell].push(id),self.envelopes[cell]=cells[cell],self.objects.hasOwnProperty(id)||(self.objects[id]=[]),self.objects[id].push(cell)})},SpatialHash.prototype.intersects=function(aabb){var intersects=[],self=this;return Object.keys(self.envelopes).forEach(function(envelope){envelope.intersectsBox(aabb)&&intersects.push(envelope)}),intersects},SpatialHash.prototype.intersectsViewSelection=function(frustum,p1,p2){},SpatialHash.prototype.near=function(pos,radius,limit){limit=limit||1/0;(new THREE.Box3).setFromCenterAndSize(pos,radius)},SpatialHash.prototype.nearest=function(pos,limit){},SpatialHash.prototype.remove=function(id){var i,self=this;this.objects.hasOwnProperty(id)&&this.objects[id].forEach(function(cell){i=self.cells[cell].indexOf(id),i>-1&&self.cells[cell].splice(i,1)}),delete this.envelopes[id],delete this.objects[id]};
//# sourceMappingURL=spatialhash.min.js.map